// Code generated by the Paddle SDK Generator; DO NOT EDIT.

package paddle

import (
	"context"
	"encoding/json"
	"strings"

	"github.com/PaddleHQ/paddle-go-sdk/v3/pkg/paddlenotification"
)

// Simulation: Represents a simulation entity.
type Simulation struct {
	// ID: Unique Paddle ID for this simulation, prefixed with `ntfsim_`.
	ID string `json:"id,omitempty"`
	// Status: Whether this entity can be used in Paddle.
	Status Status `json:"status,omitempty"`
	// NotificationSettingID: Paddle ID of the notification setting where this simulation is sent, prefixed with `ntfset_`.
	NotificationSettingID string `json:"notification_setting_id,omitempty"`
	// Name: Name of this simulation.
	Name string `json:"name,omitempty"`
	// Type: Single event sent for this simulation, in the format `entity.event_type`.
	Type SimulationTypeName `json:"type,omitempty"`
	// Payload: Simulation payload. `null` for scenarios.
	Payload paddlenotification.NotificationPayload `json:"payload,omitempty"`
	// LastRunAt: RFC 3339 datetime string of when this simulation was last run. `null` until run. Set automatically by Paddle.
	LastRunAt *string `json:"last_run_at,omitempty"`
	// CreatedAt: RFC 3339 datetime string of when this entity was created. Set automatically by Paddle.
	CreatedAt string `json:"created_at,omitempty"`
	// UpdatedAt: RFC 3339 datetime string of when this entity was updated. Set automatically by Paddle.
	UpdatedAt string `json:"updated_at,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaler interface for Notification
func (s *Simulation) UnmarshalJSON(data []byte) error {
	type alias Simulation

	if err := json.Unmarshal(data, (*alias)(s)); err != nil {
		return err
	}

	if s.Payload == nil || !strings.Contains(string(s.Type), ".") {
		return nil
	}

	var t paddlenotification.NotificationPayload
	switch strings.Split(string(s.Type), ".")[0] {
	case "address":
		t = &paddlenotification.AddressNotification{}
	case "adjustment":
		t = &paddlenotification.AdjustmentNotification{}
	case "business":
		t = &paddlenotification.BusinessNotification{}
	case "customer":
		t = &paddlenotification.CustomerNotification{}
	case "discount":
		t = &paddlenotification.DiscountNotification{}
	case "payout":
		t = &paddlenotification.PayoutNotification{}
	case "price":
		t = &paddlenotification.PriceNotification{}
	case "product":
		t = &paddlenotification.ProductNotification{}
	case "report":
		t = &paddlenotification.ReportNotification{}
	case "subscription":
		t = &paddlenotification.SubscriptionNotification{}
	case "transaction":
		t = &paddlenotification.TransactionNotification{}
	default:
		t = map[string]any{}
	}

	rawT, err := json.Marshal(s.Payload)
	if err != nil {
		return err
	}

	if err := json.Unmarshal(rawT, t); err != nil {
		return err
	}

	s.Payload = t

	return nil
}

// SimulationSingleEventCreate: Single event simulations play a single event.
type SimulationSingleEventCreate struct {
	// NotificationSettingID: Paddle ID of the notification setting where this simulation is sent, prefixed with `ntfset_`.
	NotificationSettingID string `json:"notification_setting_id,omitempty"`
	// Name: Name of this simulation.
	Name string `json:"name,omitempty"`
	// Type: Single event sent for this simulation, in the format `entity.event_type`.
	Type EventTypeName `json:"type,omitempty"`
	// Payload: Simulation payload. Pass a JSON object that matches the schema for an event type to simulate a custom payload. If omitted, Paddle populates with a demo example.
	Payload paddlenotification.NotificationPayload `json:"payload,omitempty"`
}

// SimulationScenarioType: Scenario for this simulation. Scenario simulations play all events sent for a subscription lifecycle event..
type SimulationScenarioType string

const (
	SimulationScenarioTypeSubscriptionCreation     SimulationScenarioType = "subscription_creation"
	SimulationScenarioTypeSubscriptionRenewal      SimulationScenarioType = "subscription_renewal"
	SimulationScenarioTypeSubscriptionPause        SimulationScenarioType = "subscription_pause"
	SimulationScenarioTypeSubscriptionResume       SimulationScenarioType = "subscription_resume"
	SimulationScenarioTypeSubscriptionCancellation SimulationScenarioType = "subscription_cancellation"
)

// SimulationScenarioCreate: Scenario simulations play all events sent for a subscription lifecycle event.
type SimulationScenarioCreate struct {
	// NotificationSettingID: Paddle ID of the notification setting where this simulation is sent, prefixed with `ntfset_`.
	NotificationSettingID string `json:"notification_setting_id,omitempty"`
	// Name: Name of this simulation.
	Name string `json:"name,omitempty"`
	// Type: Scenario for this simulation. Scenario simulations play all events sent for a subscription lifecycle event.
	Type SimulationScenarioType `json:"type,omitempty"`
}

// SimulationSingleEventUpdate: Single event simulations play a single event.
type SimulationSingleEventUpdate struct {
	// NotificationSettingID: Paddle ID of the notification setting where this simulation is sent, prefixed with `ntfset_`.
	NotificationSettingID string `json:"notification_setting_id,omitempty"`
	// Name: Name of this simulation.
	Name string `json:"name,omitempty"`
	// Status: Whether this entity can be used in Paddle.
	Status Status `json:"status,omitempty"`
	// Type: Single event sent for this simulation, in the format `entity.event_type`.
	Type EventTypeName `json:"type,omitempty"`
	// Payload: Simulation payload. Pass a JSON object that matches the schema for an event type to simulate a custom payload. Set to `null` to clear and populate with a demo example.
	Payload paddlenotification.NotificationPayload `json:"payload,omitempty"`
}

// SimulationScenarioUpdate: Scenario simulations play all events sent for a subscription lifecycle event.
type SimulationScenarioUpdate struct {
	// NotificationSettingID: Paddle ID of the notification setting where this simulation is sent, prefixed with `ntfset_`.
	NotificationSettingID string `json:"notification_setting_id,omitempty"`
	// Name: Name of this simulation.
	Name string `json:"name,omitempty"`
	// Status: Whether this entity can be used in Paddle.
	Status Status `json:"status,omitempty"`
	// Type: Scenario for this simulation. Scenario simulations play all events sent for a subscription lifecycle event.
	Type SimulationScenarioType `json:"type,omitempty"`
}

// SimulationsClient is a client for the Simulations resource.
type SimulationsClient struct {
	doer Doer
}

// ListSimulationsRequest is given as an input to ListSimulations.
type ListSimulationsRequest struct {
	// After is a query parameter.
	// Return entities after the specified Paddle ID when working with paginated endpoints. Used in the `meta.pagination.next` URL in responses for list operations.
	After *string `in:"query=after;omitempty" json:"-"`
	// NotificationSettingID is a query parameter.
	// Return entities related to the specified notification destination. Use a comma-separated list to specify multiple notification destination IDs.
	NotificationSettingID []string `in:"query=notification_setting_id;omitempty" json:"-"`
	// OrderBy is a query parameter.
	/*
	   Order returned entities by the specified field and direction (`[ASC]` or `[DESC]`). For example, `?order_by=id[ASC]`.

	   Valid fields for ordering: `id`.
	*/
	OrderBy *string `in:"query=order_by;omitempty" json:"-"`
	// PerPage is a query parameter.
	/*
	   Set how many entities are returned per page. Paddle returns the maximum number of results if a number greater than the maximum is requested. Check `meta.pagination.per_page` in the response to see how many were returned.

	   Default: `50`; Maximum: `200`.
	*/
	PerPage *int `in:"query=per_page;omitempty" json:"-"`
	// ID is a query parameter.
	// Return only the IDs specified. Use a comma-separated list to get multiple entities.
	ID []string `in:"query=id;omitempty" json:"-"`
	// Status is a query parameter.
	// Return entities that match the specified status. Use a comma-separated list to specify multiple status values.
	Status []string `in:"query=status;omitempty" json:"-"`
}

// ListSimulations performs the GET operation on a Simulations resource.
func (c *SimulationsClient) ListSimulations(ctx context.Context, req *ListSimulationsRequest) (res *Collection[*Simulation], err error) {
	if err := c.doer.Do(ctx, "GET", "/simulations", req, &res); err != nil {
		return nil, err
	}

	return res, nil
}

// NewCreateSimulationRequestSimulationSingleEventCreate takes a SimulationSingleEventCreate type
// and creates a CreateSimulationRequest for use in a request.
func NewCreateSimulationRequestSimulationSingleEventCreate(r *SimulationSingleEventCreate) *CreateSimulationRequest {
	return &CreateSimulationRequest{SimulationSingleEventCreate: r}
}

// NewCreateSimulationRequestSimulationScenarioCreate takes a SimulationScenarioCreate type
// and creates a CreateSimulationRequest for use in a request.
func NewCreateSimulationRequestSimulationScenarioCreate(r *SimulationScenarioCreate) *CreateSimulationRequest {
	return &CreateSimulationRequest{SimulationScenarioCreate: r}
}

// CreateSimulationRequest represents a union request type of the following types:
//   - `SimulationSingleEventCreate`
//   - `SimulationScenarioCreate`
//
// The following constructor functions can be used to create a new instance of this type.
//   - `NewCreateSimulationRequestSimulationSingleEventCreate()`
//   - `NewCreateSimulationRequestSimulationScenarioCreate()`
//
// Only one of the values can be set at a time, the first non-nil value will be used in the request.
type CreateSimulationRequest struct {
	*SimulationSingleEventCreate
	*SimulationScenarioCreate
}

// CreateSimulation performs the POST operation on a Simulations resource.
func (c *SimulationsClient) CreateSimulation(ctx context.Context, req *CreateSimulationRequest) (res *Simulation, err error) {
	if err := c.doer.Do(ctx, "POST", "/simulations", req, &res); err != nil {
		return nil, err
	}

	return res, nil
}

// MarshalJSON implements the json.Marshaler interface.
func (u CreateSimulationRequest) MarshalJSON() ([]byte, error) {
	if u.SimulationSingleEventCreate != nil {
		return json.Marshal(u.SimulationSingleEventCreate)
	}

	if u.SimulationScenarioCreate != nil {
		return json.Marshal(u.SimulationScenarioCreate)
	}

	return nil, nil
}

// GetSimulationRequest is given as an input to GetSimulation.
type GetSimulationRequest struct {
	// URL path parameters.
	SimulationID string `in:"path=simulation_id" json:"-"`
}

// GetSimulation performs the GET operation on a Simulations resource.
func (c *SimulationsClient) GetSimulation(ctx context.Context, req *GetSimulationRequest) (res *Simulation, err error) {
	if err := c.doer.Do(ctx, "GET", "/simulations/{simulation_id}", req, &res); err != nil {
		return nil, err
	}

	return res, nil
}

// NewUpdateSimulationRequestSimulationSingleEventUpdate takes a SimulationSingleEventUpdate type
// and creates a UpdateSimulationRequest for use in a request.
func NewUpdateSimulationRequestSimulationSingleEventUpdate(simulationID string, r *SimulationSingleEventUpdate) *UpdateSimulationRequest {
	return &UpdateSimulationRequest{SimulationID: simulationID, SimulationSingleEventUpdate: r}
}

// NewUpdateSimulationRequestSimulationScenarioUpdate takes a SimulationScenarioUpdate type
// and creates a UpdateSimulationRequest for use in a request.
func NewUpdateSimulationRequestSimulationScenarioUpdate(simulationID string, r *SimulationScenarioUpdate) *UpdateSimulationRequest {
	return &UpdateSimulationRequest{SimulationID: simulationID, SimulationScenarioUpdate: r}
}

// UpdateSimulationRequest represents a union request type of the following types:
//   - `SimulationSingleEventUpdate`
//   - `SimulationScenarioUpdate`
//
// The following constructor functions can be used to create a new instance of this type.
//   - `NewUpdateSimulationRequestSimulationSingleEventUpdate()`
//   - `NewUpdateSimulationRequestSimulationScenarioUpdate()`
//
// Only one of the values can be set at a time, the first non-nil value will be used in the request.
type UpdateSimulationRequest struct {
	// URL path parameters.
	SimulationID string `in:"path=simulation_id" json:"-"`

	*SimulationSingleEventUpdate
	*SimulationScenarioUpdate
}

// UpdateSimulation performs the PATCH operation on a Simulations resource.
func (c *SimulationsClient) UpdateSimulation(ctx context.Context, req *UpdateSimulationRequest) (res *Simulation, err error) {
	if err := c.doer.Do(ctx, "PATCH", "/simulations/{simulation_id}", req, &res); err != nil {
		return nil, err
	}

	return res, nil
}

// MarshalJSON implements the json.Marshaler interface.
func (u UpdateSimulationRequest) MarshalJSON() ([]byte, error) {
	if u.SimulationSingleEventUpdate != nil {
		return json.Marshal(u.SimulationSingleEventUpdate)
	}

	if u.SimulationScenarioUpdate != nil {
		return json.Marshal(u.SimulationScenarioUpdate)
	}

	return nil, nil
}
