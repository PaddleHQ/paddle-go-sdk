// Code generated by the Paddle SDK Generator; DO NOT EDIT.

package paddleerr

import (
	"fmt"
	"strings"
	"time"
)

// RetryAfter represents the Retry-After header of 429/503 error responses
// from the Paddle API. This surfaces API retry expectations and allows
// integrators to implement backoff accordingly.
type RetryAfter struct {
	// IssuedAt is when the 429/503 response was received
	IssuedAt time.Time
	// RetryAt is the specific point in time the server allows retries
	RetryAt time.Time
}

// TotalDelay returns the static duration between issuance and the retry target.
func (r *RetryAfter) TotalDelay() time.Duration {
	return r.RetryAt.Sub(r.IssuedAt)
}

// WaitTime returns the duration from now until the retry target.
// It returns 0 if the time has already passed, preventing negative durations.
func (r *RetryAfter) WaitTime() time.Duration {
	wait := time.Until(r.RetryAt)
	if wait < 0 {
		return 0
	}
	return wait
}

// IsExpired returns true if the current time is past the retry target.
func (r *RetryAfter) IsExpired() bool {
	return time.Now().After(r.RetryAt)
}

type ErrorType string

type Error struct {
	Status     int         `json:"-"`
	RetryAfter *RetryAfter `json:"-"`

	Type             ErrorType         `json:"type"`
	Code             string            `json:"code"`
	Detail           string            `json:"detail"`
	DocumentationURL string            `json:"documentation_url"`
	Extra            map[string]any    `json:"extra"`
	Errors           []ValidationError `json:"errors,omitempty"`
}

type ValidationError struct {
	Field   string `json:"field"`
	Message string `json:"message"`
}

const (
	ErrorTypeAPIError     ErrorType = "api_error"
	ErrorTypeRequestError ErrorType = "request_error"
)

// Error conforms to the errors interface.
// It returns a string representation of the error, which contains the type and
// code of the error, and the detail if it exists.
// If the documentation URL exists, it will be appended to the end of the string.
func (e *Error) Error() string {
	var sb strings.Builder

	sb.WriteString(fmt.Sprintf("%s.%s", e.Type, e.Code))

	if e.Detail != "" {
		sb.WriteString(fmt.Sprintf(": %s", e.Detail))
	}

	if e.DocumentationURL != "" {
		sb.WriteString(fmt.Sprintf(" (%s)", e.DocumentationURL))
	}

	for _, e := range e.Errors {
		sb.WriteString(fmt.Sprintf("\n  - %s: %s", e.Field, e.Message))
	}

	return sb.String()
}

// Is returns true if the target error is a *Error and the error type and code match.
func (e *Error) Is(target error) bool {
	targetAsserted, targetOk := target.(*Error)

	if !targetOk {
		return false
	}

	return (e.Code == targetAsserted.Code && e.Type == targetAsserted.Type)
}
