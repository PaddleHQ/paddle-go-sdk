// Code generated by the Paddle SDK Generator; DO NOT EDIT.

package paddleerr

import (
	"fmt"
	"strings"
)

type ErrorType string

type Error struct {
	Status           int               `json:"-"`
	Type             ErrorType         `json:"type"`
	Code             string            `json:"code"`
	Detail           string            `json:"detail"`
	DocumentationURL string            `json:"documentation_url"`
	Extra            map[string]any    `json:"extra"`
	Errors           []ValidationError `json:"errors,omitempty"`
}

type ValidationError struct {
	Field   string `json:"field"`
	Message string `json:"message"`
}

const (
	ErrorTypeRequestError ErrorType = "request_error"
	ErrorTypeAPIError     ErrorType = "api_error"
)

// Error conforms to the errors interface.
// It returns a string representation of the error, which contains the type and
// code of the error, and the detail if it exists.
// If the documentation URL exists, it will be appended to the end of the string.
func (e *Error) Error() string {
	var sb strings.Builder

	sb.WriteString(fmt.Sprintf("%s.%s", e.Type, e.Code))

	if e.Detail != "" {
		sb.WriteString(fmt.Sprintf(": %s", e.Detail))
	}

	if e.DocumentationURL != "" {
		sb.WriteString(fmt.Sprintf(" (%s)", e.DocumentationURL))
	}

	for _, e := range e.Errors {
		sb.WriteString(fmt.Sprintf("\n  - %s: %s", e.Field, e.Message))
	}

	return sb.String()
}

// Is returns true if the target error is a *Error and the error type and code match.
func (e *Error) Is(target error) bool {
	targetAsserted, targetOk := target.(*Error)

	if !targetOk {
		return false
	}

	return (e.Code == targetAsserted.Code && e.Type == targetAsserted.Type)
}
